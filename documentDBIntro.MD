# Document databases, e.g. MongoDB

Document databases can be thought of as somewhere between relational databases and key-value databases. Document databases, like key-value databases, are based on storing values ​​based on a key. However, values ​​or *documents* as they are called in the context of document bases can be very complex objects in themselves, which contain fields whose value can be either normal values ​​such as numbers and strings or other objects. Unlike key-value databases, document databases "see" inside the documents stored in the database, and enable queries made regarding the contents of the stored documents.

In the following, we will use the entries of the most popular document database <a href="https://www.mongodb.org/">MongoDB</a> as an example.

<br/>

Document bases usually use <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> as the logical representation of information. Below is the JSON document presenting the course *Basics of Programming*:


```javascript
{
  "id": ObjectId("10"),
  "name": "Basics of Programming",
  "units": 5,
  "lecturer": [ "A Youtube Personality" ]
}
```

A JSON document consists of key-value pairs. The value corresponding to the key is marked with a colon, separated from the key.

The course document therefore has four key-value pairs. It can be thought that the course has four fields. Among these fields, the key field `id` automatically generated by MongoDB for the document has a special position, the value of which is of type `ObjectId`. What differs from relational databases is that the value of the field can be a table.

The following is a document describing the student:


```javascript
{
  "id" : ObjectId("59"),
  "name": "Randy Lau",
  "student number" : 14112345,
  "address" : {
                "street" : "540 Howard St",
                "zip code" : "94105",
                "city": "San Francisco"
             }
}
```

Now the address of the field is an *object* which has its own fields.

In the document database, the documents are sorted into *collections* (eng. collection). The meaning of a collection is roughly the same as in a table's relational database. However, the documents in one collection do not have to be the same in terms of fields. There can be a variable number of fields, and fields with the same name can contain a different type of value in different documents. No schema of any kind is defined for the collections in the document databases, i.e. it is entirely the responsibility of the applications that reasonable data is stored in the database, and that the data read from the database is examined correctly.

As we saw above with the student, it is possible to include objects within each other in document databases. The situation could also have been modeled like a "relational model" so that there would be its own collection for addresses, and a single address would be modeled as its own document:


```javascript
{
  "id" : ObjectId("123"),
  "street" : "540 Howard St",
  "zip code" : "94105",
  "city": "San Francisco"
}
```

The student document would now only contain a reference to the address document:


```javascript
{
  "id" : ObjectId("59"),
  "name": "Randy Lau",
  "student number" : 14112345,
  "address" : ObjectId("123")
}
```

Unlike in the case of relational databases, document databases *do not offer* *join operations* that take place at the database level, and in the case of the previous example, the application itself would have to ensure that when searching for a student, the student's address is also searched for in the database.

Although the operation is not supported at the document base level, there are many libraries that implement the join operation programmatically so that the application program does not have to worry about it.

In relational databases, creating a base schema is so easy that when aiming for a normalized solution, in most situations there is about one "sensible" solution that works almost equally well regardless of how the base is used.

The situation is different when it comes to documentary stocks. Let's examine, for example, Courses and Students' course performance. In a relational database, the situation would be straightforward, *Performance* would be a connection table of *Course* and *Student*.

One possibility would be to make exactly the same solution in the document base.

Collection Student:

```javascript
[
  {
    "id": ObjectId("10"),
    "name" : "Powercat",
    "student number" : 13457678
  },
  {
    "id": ObjectId("11"),
    "name": "Randy Lau",
    "student number" : 14012345
  }
]
```

Collection course:

```javascript
[
  {
    "id": ObjectId("34"),
    "name" : "Basics of Programming",
    "scope" : 5
  },
  {
    "id": ObjectId("35"),
    "name" : "Computer as a work tool",
    "scope" : 1
  }
]
```

The execution would now be a "joint-table" collection:


```javascript
[
  {
    "id": 55
    "course_id" : ObjectId("34"),
    "student_id" : ObjectId("10"),
    "grade": 4
  },
  {
    "id": 56
    "course_id" : ObjectId("35"),
    "student_id" : ObjectId("10"),
    "grade" : 5
  },
  {
    "id": 57
    "course_id" : ObjectId("35"),
    "student_id" : ObjectId("11"),
    "grade" : 2
  }
]
```

However, there are also other options. Depending on the use cases, it might be advantageous to store the information about the performance (the id of the "joining document") also in connection with the course and the student:

Collection Student:

```javascript
[
  {
    "id": ObjectId("10")
    "name" : "Powercat",
    "student number" : 13457678,
    "performances" : [ ObjectId("55"), ObjectId("56") ]
  },
  {
    "id": ObjectId("11")
    "name": "Randy Lau",
    "student number" : 14012345,
    "executions" : [ ObjectId("57") ]
  }
]
```

Collection course:

```javascript
[
  {
    "id": ObjectId("34")
    "name" : "Basics of Programming",
    "scope" : 5,
    "executors" : [ObjectId("10")]
  },
  {
    "id": ObjectId("35")
    "name" : "Computer as a work tool",
    "scope" : 1,
    "executors" : [ObjectId("10"), ObjectId("11")]
  }
]
```

In some cases, the best solution would be to abandon the documents that function as a link, i.e. the collection of achievements, and deposit the achievements in their entirety in the student documents:

```javascript
[
  {
    "id": ObjectId("10")
    "name" : "Powercat",
    "student number" : 13457678,
    "performances" : [
      {
        "id": 55
        "course_id" : ObjectId("34"),
        "grade": 4
      },
      {
        "id": 56
        "course_id" : ObjectId("35"),
        "grade" : 5
      }
    ]
  },
  {
    "id": ObjectId("11")
    "name": "Randy Lau",
    "student number" : 14012345,
    "performances" : [
      {
        "id": 57
        "course_id" : ObjectId("35"),
        "grade" : 2
      }
    ]
  }
]
```

This solution would make it difficult to find out who completed the course, so in some use cases it might be advantageous to include the completions in *both* students and the course.

There is no single "correct" answer as to how the data of the application should be modeled into collections and documents. The best way is greatly influenced by the usage profile of the application being built: you should choose a data model in such a way that it makes the execution of the most common operations quick and easy.

As we already stated, document bases do not support join operations, and queries always target only one collection. Document bases do not have any standardized query language, the query language of each base is completely unique. For example, MongoDB's query language does not resemble SQL very closely.

The document bases also do not support the simultaneous transactional change of several collections. However, all transactions performed on a single collection are always done transactionally.
